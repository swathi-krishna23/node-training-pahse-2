"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GetPropertyState = void 0;
const Utilities_1 = require("../Utilities");
const SubstituteBase_1 = require("../SubstituteBase");
class GetPropertyState {
    constructor(_property) {
        this._property = _property;
        this._mocks = [];
        this._recordedCalls = [];
        this._isFunctionState = false;
    }
    get property() {
        return this._property;
    }
    get isFunctionState() {
        return this._isFunctionState;
    }
    get callCount() {
        return this._recordedCalls.length;
    }
    getCallCount(args) {
        const callFilter = (recordedCall) => Utilities_1.areArgumentArraysEqual(recordedCall, args);
        return this._recordedCalls.filter(callFilter).length;
    }
    applySubstituteMethodLogic(substituteMethod, mockValue, args) {
        switch (substituteMethod) {
            case Utilities_1.SubstituteMethods.resolves:
                return Promise.resolve(mockValue);
            case Utilities_1.SubstituteMethods.rejects:
                return Promise.reject(mockValue);
            case Utilities_1.SubstituteMethods.returns:
                return mockValue;
            case Utilities_1.SubstituteMethods.throws:
                throw mockValue;
            case Utilities_1.SubstituteMethods.mimicks:
                return mockValue.apply(mockValue, args);
            default:
                throw SubstituteBase_1.SubstituteException.generic(`Method ${substituteMethod} not implemented`);
        }
    }
    processProperty(context, args, propertyType) {
        const hasExpectations = context.initialState.hasExpectations;
        if (!hasExpectations) {
            this._recordedCalls.push(args);
            const foundSubstitute = this._mocks.find(mock => Utilities_1.areArgumentArraysEqual(mock.arguments, args));
            if (foundSubstitute !== void 0) {
                const mockValue = foundSubstitute.mockValues.length > 1 ?
                    foundSubstitute.mockValues.shift() :
                    foundSubstitute.mockValues[0];
                return this.applySubstituteMethodLogic(foundSubstitute.substituteType, mockValue, args);
            }
        }
        context.initialState.assertCallCountMatchesExpectations(this._recordedCalls, this.getCallCount(args), propertyType, this.property, args);
        return context.proxy;
    }
    apply(context, args) {
        if (!this._isFunctionState) {
            this._isFunctionState = true;
            this._recordedCalls = [];
        }
        this._lastArgs = args;
        return this.processProperty(context, args, Utilities_1.PropertyType.method);
    }
    set(context, property, value) { }
    isSubstituteMethod(property) {
        return property === Utilities_1.SubstituteMethods.returns ||
            property === Utilities_1.SubstituteMethods.mimicks ||
            property === Utilities_1.SubstituteMethods.throws ||
            property === Utilities_1.SubstituteMethods.resolves ||
            property === Utilities_1.SubstituteMethods.rejects;
    }
    sanitizeSubstituteMockInputs(mockInputs) {
        if (mockInputs.length === 0)
            return [undefined];
        return mockInputs.length > 1 ?
            [...mockInputs, undefined] :
            [...mockInputs];
    }
    get(context, property) {
        if (property === 'then')
            return void 0;
        if (this.isSubstituteMethod(property)) {
            return (...inputs) => {
                const mockInputs = this.sanitizeSubstituteMockInputs(inputs);
                const args = this._isFunctionState ? this._lastArgs : [];
                if (args === void 0)
                    throw SubstituteBase_1.SubstituteException.generic('Eh, there\'s a bug, no args recorded :/');
                this._mocks.push({
                    arguments: args,
                    mockValues: mockInputs,
                    substituteType: property
                });
                this._recordedCalls.pop();
                context.state = context.initialState;
            };
        }
        if (this._isFunctionState)
            return context.proxy;
        return this.processProperty(context, [], Utilities_1.PropertyType.property);
    }
}
exports.GetPropertyState = GetPropertyState;
