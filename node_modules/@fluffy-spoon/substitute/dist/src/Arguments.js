"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Arg = exports.AllArguments = exports.Argument = void 0;
class BaseArgument {
    constructor(_description, _matchingFunction, _options) {
        this._description = _description;
        this._matchingFunction = _matchingFunction;
        this._options = _options;
    }
    matches(arg) {
        var _a, _b;
        const inverseMatch = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.inverseMatch) !== null && _b !== void 0 ? _b : false;
        return inverseMatch ? !this._matchingFunction(arg) : this._matchingFunction(arg);
    }
    toString() {
        return this._description;
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return this._description;
    }
}
class Argument extends BaseArgument {
    constructor(description, matchingFunction, options) {
        super(description, matchingFunction, options);
        this._type = 'SingleArgument';
    }
    get type() {
        return this._type;
    }
}
exports.Argument = Argument;
class AllArguments extends BaseArgument {
    constructor() {
        super('{all}', () => true, {});
        this._type = 'AllArguments';
    }
    get type() {
        return this._type;
    }
}
exports.AllArguments = AllArguments;
var Arg;
(function (Arg) {
    const factory = (factoryF) => (...args) => factoryF(...args);
    const toStringify = (obj) => {
        if (typeof obj.inspect === 'function')
            return obj.inspect();
        if (typeof obj.toString === 'function')
            return obj.toString();
        return obj;
    };
    Arg.all = () => new AllArguments();
    const isFunction = (predicate, options) => new Argument(`{predicate ${toStringify(predicate)}}`, predicate, options);
    const isArgFunction = (predicate) => factory(isFunction)(predicate);
    isArgFunction.not = (predicate) => factory(isFunction)(predicate, { inverseMatch: true });
    Arg.is = isArgFunction;
    const anyFunction = (type = 'any', options) => {
        const description = !type ? '{any arg}' : `{type ${type}}`;
        const predicate = (x) => {
            switch (type) {
                case 'any':
                    return true;
                case 'array':
                    return Array.isArray(x);
                default:
                    return typeof x === type;
            }
        };
        return new Argument(description, predicate, options);
    };
    const anyArgFunction = (type) => factory(anyFunction)(type);
    anyArgFunction.not = (type) => factory(anyFunction)(type, { inverseMatch: true });
    Arg.any = anyArgFunction;
})(Arg = exports.Arg || (exports.Arg = {}));
