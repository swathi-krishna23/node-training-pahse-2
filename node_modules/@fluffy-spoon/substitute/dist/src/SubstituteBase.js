"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubstituteException = exports.SubstituteJS = void 0;
const util_1 = require("util");
const Utilities_1 = require("./Utilities");
class SubstituteJS {
    constructor() {
        this.length = `[class ${this.constructor.name}] -> ${this.lastRegisteredSubstituteJSMethodOrProperty}`;
    }
    set lastRegisteredSubstituteJSMethodOrProperty(value) {
        this._lastRegisteredSubstituteJSMethodOrProperty = value;
    }
    get lastRegisteredSubstituteJSMethodOrProperty() {
        return typeof this._lastRegisteredSubstituteJSMethodOrProperty === 'undefined' ? 'root' : this._lastRegisteredSubstituteJSMethodOrProperty;
    }
    [Symbol.toPrimitive]() {
        return `[class ${this.constructor.name}] -> ${this.lastRegisteredSubstituteJSMethodOrProperty}`;
    }
    [Symbol.toStringTag]() {
        return `[class ${this.constructor.name}] -> ${this.lastRegisteredSubstituteJSMethodOrProperty}`;
    }
    [Symbol.iterator]() {
        return `[class ${this.constructor.name}] -> ${this.lastRegisteredSubstituteJSMethodOrProperty}`;
    }
    [util_1.inspect.custom]() {
        return `[class ${this.constructor.name}] -> ${this.lastRegisteredSubstituteJSMethodOrProperty}`;
    }
    valueOf() {
        return `[class ${this.constructor.name}] -> ${this.lastRegisteredSubstituteJSMethodOrProperty}`;
    }
    $$typeof() {
        return `[class ${this.constructor.name}] -> ${this.lastRegisteredSubstituteJSMethodOrProperty}`;
    }
    toString() {
        return `[class ${this.constructor.name}] -> ${this.lastRegisteredSubstituteJSMethodOrProperty}`;
    }
    inspect() {
        return `[class ${this.constructor.name}] -> ${this.lastRegisteredSubstituteJSMethodOrProperty}`;
    }
}
exports.SubstituteJS = SubstituteJS;
var SubstituteExceptionTypes;
(function (SubstituteExceptionTypes) {
    SubstituteExceptionTypes["CallCountMissMatch"] = "CallCountMissMatch";
    SubstituteExceptionTypes["PropertyNotMocked"] = "PropertyNotMocked";
})(SubstituteExceptionTypes || (SubstituteExceptionTypes = {}));
class SubstituteException extends Error {
    constructor(msg, exceptionType) {
        super(msg);
        Error.captureStackTrace(this, SubstituteException);
        this.name = new.target.name;
        this.type = exceptionType;
    }
    static forCallCountMissMatch(callCount, property, calls) {
        const message = 'Expected ' + (callCount.expected === null ? '1 or more' : callCount.expected) +
            ' call' + (callCount.expected === 1 ? '' : 's') + ' to the ' + property.type + ' ' + property.value.toString() +
            ' with ' + Utilities_1.stringifyArguments(calls.expectedArguments) + ', but received ' + (callCount.received === 0 ? 'none' : callCount.received) +
            ' of such call' + (callCount.received === 1 ? '' : 's') +
            '.\nAll calls received to ' + property.type + ' ' + property.value.toString() + ':' + Utilities_1.stringifyCalls(calls.received);
        return new this(message, SubstituteExceptionTypes.CallCountMissMatch);
    }
    static forPropertyNotMocked(property) {
        return new this(`There is no mock for property: ${String(property)}`, SubstituteExceptionTypes.PropertyNotMocked);
    }
    static generic(message) {
        return new this(message);
    }
}
exports.SubstituteException = SubstituteException;
