declare type PredicateFunction<T> = (arg: T) => boolean;
declare type ArgumentOptions = {
    inverseMatch?: boolean;
};
declare class BaseArgument<T> {
    private _description;
    private _matchingFunction;
    private _options?;
    constructor(_description: string, _matchingFunction: PredicateFunction<T>, _options?: ArgumentOptions);
    matches(arg: T): boolean;
    toString(): string;
}
export declare class Argument<T> extends BaseArgument<T> {
    private readonly _type;
    constructor(description: string, matchingFunction: PredicateFunction<T>, options?: ArgumentOptions);
    get type(): 'SingleArgument';
}
export declare class AllArguments<T extends any[]> extends BaseArgument<T> {
    private readonly _type;
    constructor();
    get type(): 'AllArguments';
}
export declare namespace Arg {
    type ExtractFirstArg<T> = T extends AllArguments<infer TArgs> ? TArgs[0] : T;
    type ReturnArg<T> = Argument<T> & T;
    type Inversable<T> = T & {
        not: T;
    };
    export const all: <T extends any[]>() => AllArguments<T>;
    type Is = <T>(predicate: PredicateFunction<ExtractFirstArg<T>>) => ReturnArg<ExtractFirstArg<T>>;
    export const is: Inversable<Is>;
    type MapAnyReturn<T> = T extends 'any' ? ReturnArg<any> : T extends 'string' ? ReturnArg<string> : T extends 'number' ? ReturnArg<number> : T extends 'boolean' ? ReturnArg<boolean> : T extends 'symbol' ? ReturnArg<symbol> : T extends 'undefined' ? ReturnArg<undefined> : T extends 'object' ? ReturnArg<object> : T extends 'function' ? ReturnArg<Function> : T extends 'array' ? ReturnArg<any[]> : any;
    type AnyType = 'string' | 'number' | 'boolean' | 'symbol' | 'undefined' | 'object' | 'function' | 'array' | 'any';
    type Any = <T extends AnyType = 'any'>(type?: T) => MapAnyReturn<T>;
    export const any: Inversable<Any>;
    export {};
}
export {};
